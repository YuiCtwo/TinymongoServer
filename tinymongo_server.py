import socket
import struct
import threading

from argparse import ArgumentParser


from backend.op_code import OpCode
from backend.parser import HeadParser, byte2string
from backend.tinymongodb.handler import TinyMongoDBBackend
from utils.http_utils import payload2response, payload2compressed_response, payload2msg_response
from utils.logger import server_logger
from utils.multi_thread_wrapper import LoopThread


class IDGenerator:
    def __init__(self):
        self.id = 0

    def get_one(self):
        self.id += 1
        return self.id

class TinyMongoServer:

    def __init__(self, host='127.0.0.1', port=27017):
        self.host = host
        self.port = port
        self.hostname = socket.gethostname()
        #
        self.handler = TinyMongoDBBackend(
            hostname=self.hostname,
            port=self.port)
        self.logger = server_logger
        self.head_handler = HeadParser()
        # demo list that stores allowed commands
        self.allowed_commands = self.handler.allowed_commands
        self.id_generator = IDGenerator()

        self._build_socket()
        # self.response_parse = payload2response
        self.response_parse_msg = payload2msg_response
        self.response_parse = payload2response
        self.looper_threads = []

    def _build_socket(self):
        self.server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        self.server_socket.bind((self.host, self.port))
        # set maximum number of connections
        self.server_socket.listen(5)
        # log server start
        self.logger.info(f"Server started on {self.host}:{self.port}")
        print(f"Server started on {self.host}:{self.port}")

    def start_server(self):

        while True:
            client_socket, client_address = self.server_socket.accept()
            # receive data from client
            print(f'Accept new connection from {client_address}...')
            t = threading.Thread(target=self._handle_request, args=(client_socket, client_address, ))
            # self._handle_request(client_socket)
            # make sure that thread ends when the main thread is terminated
            t.daemon = True
            t.start()


    def __del__(self):
        self.server_socket.close()

    def _handle_request(self, client_socket, client_address):
        while True:
            try:
                data = client_socket.recv(4096)
                if not data:
                    break
            except ConnectionResetError as e:
                self.logger.error(f"Connection closed by client")
                break
            except ConnectionAbortedError as e:
                self.logger.error(f"Connection aborted by client")
                break
            header = self.head_handler.do_decode(data)
            op_code = header["op_code"]
            request_id = header["request_id"]
            # self.logger.info(f"Received request with op_code {op_code}")
            if op_code in self.allowed_commands:
                payload = self.handler.handle_decode(op_code, data)
                # TODO: reorganize code here for adding additional information to payload
                # payload["client_address"] = client_address
                self.logger.info(f"Request payload: {payload}")
                handler_func = self.allowed_commands[op_code]
                response = handler_func(data)
                self.logger.info(f"Sending Response: {response}")
            else:
                response = {}
            # some of the command may not need to return any response
            # the request_id for response is generated by the server itself
            if response:
                if op_code == OpCode.OP_QUERY:
                    response_raw = self.response_parse(request_id, self.id_generator.get_one(), response)
                    client_socket.sendall(response_raw)

                elif op_code == OpCode.OP_MSG:
                    response_raw = self.response_parse_msg(request_id, self.id_generator.get_one(), response)
                    client_socket.sendall(response_raw)
        client_socket.close()


if __name__ == '__main__':
    arg_parser = ArgumentParser(description="TinyMongo Server")
    arg_parser.add_argument("--port", type=int, default=27019, help="Server port")
    arg_parser.add_argument("--host", type=str, default='127.0.0.1', help="Server host")
    args = arg_parser.parse_args()
    server = TinyMongoServer(host=args.host, port=args.port)
    server.start_server()
